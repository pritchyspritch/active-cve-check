import os
import re
import csv
from collections import defaultdict
import json

import click
import paramiko
from ares import CVESearch

PRIORITY_PATTERNS = {
    "low": re.compile("Priority:"),
    "medium": re.compile("Priority: [mh]"),
    "high": re.compile("Priority: [h]"),
}
CVE = CVESearch()

CVE_DETAILS_TEMPLATE = """
CVE: {id}
Package: {package}
CVSS: {cvss}
CVSS 2.0 Severity: {severity}
Published: {published}
Modified: {modified}
Summary: {summary}
References: {references}
"""
CVE_NO_DETAILS_TEMPLATE = """
CVE: {id}
Package: {package}
No further details available.
"""


@click.group()
def scan():
    pass


@scan.command()
@click.argument("packages_listing", type=click.File("rb"))
@click.argument(
    "active_cve_directory", type=click.Path(exists=True, dir_okay=True, file_okay=False)
)
@click.option("--ubuntu-version", default="xenial")
@click.option(
    "--priority-threshold",
    default="medium",
    type=click.Choice(PRIORITY_PATTERNS.keys()),
)
@click.option("--any-status", is_flag=True)
def scan_packages(
    packages_listing,
    active_cve_directory,
    ubuntu_version,
    priority_threshold,
    any_status,
):
    cves = load_cves(active_cve_directory, ubuntu_version, priority_threshold)
    next(packages_listing)  # remove header
    for package_line in packages_listing:
        package, _, _ = package_line.partition(b"/")
        package = package.decode("utf-8")
        if package in cves:
            output_details(package, cves[package], any_status)


def output_details(package, cves, any_status=False):
    for cve, status in cves:
        if any_status:
            print_cve(cve, package)
        elif "need" in status:
            print_cve(cve, package)


def print_cve(cve, package):
    details = json.loads(CVE.id(cve).decode("utf-8"))
    if details:
        severity = {"severity": get_cvss_severity(details)}
        details.update(severity)
        print(
            CVE_DETAILS_TEMPLATE.format(
                id=cve,
                package=package,
                cvss=details["cvss"],
                severity=details["severity"],
                published=details["Published"],
                modified=details["Modified"],
                summary=details["summary"],
                references=" ".join(details["references"]),
            )
        )
    else:
        print(CVE_NO_DETAILS_TEMPLATE.format(id=cve, package=package))


def load_cves(active_cve_directory, ubuntu_version, threshold):
    cves = defaultdict(list)
    package_regex = re.compile(
        "{}_(?P<package_name>[\w_-]*): (?P<status>\w*)".format(ubuntu_version)
    )
    for filename in filter(
        lambda fn: fn.startswith("CVE"), os.listdir(active_cve_directory)
    ):
        with open(os.path.join(active_cve_directory, filename)) as f:
            contents = f.read()
            matches = []
            if re.search(PRIORITY_PATTERNS[threshold], contents) != None:
                matches = re.finditer(package_regex, contents)
            for match in matches:
                match_dict = match.groupdict()
                cves[match_dict["package_name"]].append(
                    (filename, match_dict["status"])
                )
    return cves


def get_cvss_severity(details):
    cvss = details["cvss"]
    if cvss > 6.9:
        severity = "High Risk"
    elif cvss > 3.9:
        severity = "Medium Risk"
    else:
        severity = "Low Risk"
    return severity


@click.group()
def ssh_packages():
    pass


@ssh_packages.command()
@click.option("--username")
@click.option(
    "--server",
    help="The IP or domain name of the server you want to connect to, this can be the internal IP if you're using a jumpbox.",
)
@click.option(
    "--jumpbox_public_addr", help="The public IP or domain name of your jumpbox."
)
@click.option("--jumpbox_private_addr", help="The private IP of your jumpbox.")
@click.option(
    "--ssh_key",
    help="Full path to your SSH key.",
    default=f"{os.getenv('HOME')}/.ssh/id_rsa",
)
def apt_list_installed(
    username, server, ssh_key, jumpbox_public_addr=None, jumpbox_private_addr=None
):

    if jumpbox_public_addr and jumpbox_private_addr:
        jumpbox = paramiko.SSHClient()
        jumpbox.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        jumpbox.connect(jumpbox_public_addr, username, key_filename=ssh_key)

        jumpbox_transport = jumpbox.get_transport()
        src_addr = (jumpbox_private_addr, 22)
        dest_addr = (target_addr, 22)
        jumpbox_channel = jumpbox_transport.open_channel(
            "direct-tcpip", dest_addr, src_addr
        )
        sock = jumpbox_channel
    else:
        sock = None

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    client.connect(server, username, key_filename=ssh_key)
    stdin, stdout, stderr = client.exec_command("apt list --installed")
    output = stdout.readlines()
    file = open("installed_packages.txt", "w")
    file.write("".join(output))
    file.close()
    client.close()
    jumpbox.close()


cli = click.CommandCollection(sources=[scan, ssh_packages])


if __name__ == "__main__":
    cli()
