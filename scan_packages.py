import os
import re
import csv
from collections import defaultdict
import json

import click
import paramiko
from ares import CVESearch

PRIORITY_PATTERNS = {
    "low": re.compile("Priority:"),
    "medium": re.compile("Priority: [mh]"),
    "high": re.compile("Priority: [h]"),
}
CVE = CVESearch()

CVE_DETAILS_TEMPLATE = """
CVE: {id}
Package: {package}
CVSS: {cvss}
CVSS 2.0 Severity: {severity}
Published: {published}
Modified: {modified}
Summary: {summary}
References: {references}
"""
CVE_NO_DETAILS_TEMPLATE = """
CVE: {id}
Package: {package}
No further details available.
"""


@click.group()
def scan_packages():
    pass


@scan_packages.command()
@click.argument("packages_listing", type=click.File("rb"))
@click.argument(
    "active_cve_directory", type=click.Path(exists=True, dir_okay=True, file_okay=False)
)
@click.option("--ubuntu-version", default="xenial")
@click.option(
    "--priority-threshold",
    default="medium",
    type=click.Choice(PRIORITY_PATTERNS.keys()),
)
@click.option("--any-status", is_flag=True)
def scan(
    packages_listing,
    active_cve_directory,
    any_status,
    ubuntu_version="xenial",
    priority_threshold="medium",
    auto_scan=False,
):
    """Scan your packages listing for CVE numbers"""
    cves = load_cves(active_cve_directory, ubuntu_version, priority_threshold)
    if auto_scan:
        open(packages_listing, "rb")
        packages_listing.read()

    next(packages_listing)  # remove header
    for package_line in packages_listing:
        package, _, _ = package_line.partition(b"/")
        package = package.decode("utf-8")
        if package in cves:
            output_details(package, cves[package], any_status)
    packages_listing.close()


def output_details(package, cves, any_status=False):
    for cve, status in cves:
        if any_status:
            print_cve(cve, package)
        elif "need" in status:
            print_cve(cve, package)


def print_cve(cve, package):
    details = json.loads(CVE.id(cve).decode("utf-8"))
    if details:
        severity = {"severity": get_cvss_severity(details)}
        details.update(severity)
        print(
            CVE_DETAILS_TEMPLATE.format(
                id=cve,
                package=package,
                cvss=details["cvss"],
                severity=details["severity"],
                published=details["Published"],
                modified=details["Modified"],
                summary=details["summary"],
                references=" ".join(details["references"]),
            )
        )
    else:
        print(CVE_NO_DETAILS_TEMPLATE.format(id=cve, package=package))


def load_cves(active_cve_directory, ubuntu_version, threshold):
    cves = defaultdict(list)
    package_regex = re.compile(
        "{}_(?P<package_name>[\w_-]*): (?P<status>\w*)".format(ubuntu_version)
    )
    for filename in filter(
        lambda fn: fn.startswith("CVE"), os.listdir(active_cve_directory)
    ):
        with open(os.path.join(active_cve_directory, filename)) as f:
            contents = f.read()
            matches = []
            if re.search(PRIORITY_PATTERNS[threshold], contents) != None:
                matches = re.finditer(package_regex, contents)
            for match in matches:
                match_dict = match.groupdict()
                cves[match_dict["package_name"]].append(
                    (filename, match_dict["status"])
                )
    return cves


def get_cvss_severity(details):
    cvss = details["cvss"]
    if cvss > 6.9:
        severity = "High Risk"
    elif cvss > 3.9:
        severity = "Medium Risk"
    else:
        severity = "Low Risk"
    return severity


@click.group()
def ssh_packages():
    pass


@ssh_packages.command()
@click.option("--user")
@click.option(
    "--server",
    help="The IP or domain name of the server you want to connect to, this can be the internal IP if you're using a jumpbox.",
)
@click.option(
    "--jumpbox_public_addr",
    default=None,
    help="The public IP or domain name of your jumpbox.",
)
@click.option(
    "--jumpbox_private_addr", default=None, help="The private IP of your jumpbox."
)
@click.option(
    "--ssh_key",
    help="Full path to your SSH key.",
    default=f"{os.getenv('HOME')}/.ssh/id_rsa",
)
@click.option("--key_passphrase", help="Passphrase for your SSH key.", default=None)
@click.option(
    "--auto_scan", help="Automatically scan packages after download", default=False
)
def apt_list_installed(
    user,
    server,
    ssh_key,
    jumpbox_public_addr,
    jumpbox_private_addr,
    key_passphrase,
    auto_scan,
):
    """SSH into server for package listing"""

    if jumpbox_public_addr and jumpbox_private_addr:
        jumpbox = paramiko.SSHClient()
        jumpbox.load_system_host_keys()
        jumpbox.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        jumpbox.connect(
            hostname=jumpbox_public_addr,
            username=user,
            password=key_passphrase,
            key_filename=ssh_key,
        )

        jumpbox_transport = jumpbox.get_transport()
        jumpbox_channel = jumpbox_transport.open_channel(
            "direct-tcpip", (jumpbox_private_addr, 22), (server, 22)
        )
    else:
        jumpbox_channel = None

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    client.connect(
        hostname=server,
        username=user,
        password=key_passphrase,
        key_filename=ssh_key,
        sock=jumpbox_channel,
    )
    stdin, stdout, stderr = client.exec_command("apt list --installed")
    output = stdout.readlines()
    packages_listing = "installed_packages.txt"
    file = open(packages_listing, "w")
    file.write("".join(output))
    file.close()
    client.close()
    jumpbox.close()

    if auto_scan:
        active_cve_directory = "../ubuntu-cve-tracker/active"
        scan(packages_listing, active_cve_directory)
    else:
        print("Ask user")


cli = click.CommandCollection(sources=[scan_packages, ssh_packages])


if __name__ == "__main__":
    cli()
