import os
import sys
import re
import csv
from collections import defaultdict
import json
from operator import itemgetter


import click
import paramiko
from ares import CVESearch
from addict import Dict
import getpass


PRIORITY_PATTERNS = {
    "low": re.compile("Priority:"),
    "medium": re.compile("Priority: [mh]"),
    "high": re.compile("Priority: [h]"),
    "critical": re.compile("Priority: [c]")
}
CVE = CVESearch()


CVE_DETAILS_TEMPLATE = """
CVE: {id}
Package: {package}
CVSS: {cvss}
CVSS 2.0 Severity: {severity}
Published: {published}
Modified: {modified}
Summary: {summary}
References: {references}
"""


CVE_NO_DETAILS_TEMPLATE = """
CVE: {id}
Package: {package}
No further details available.
"""

SEVERITY_FILE_TEMPLATE = """
{package}   {cve}   {cvss}  {comments}

"""

USEFUL_INFO_TEMPLATE = """
{cve}
https://nvd.nist.gov/vuln/detail/{cve}
https://people.canonical.com/~ubuntu-security/cve/{year}/{cve}

"""

critical = []
high = []
medium = []
low = []
cve_output = []
package_lists = defaultdict(lambda: defaultdict(dict))


@click.group()
def scan_packages():
    pass


@scan_packages.command()
@click.argument("packages_listing", type=click.File("rb"))
@click.argument(
    "active_cve_directory", type=click.Path(exists=True, dir_okay=True, file_okay=False)
)
@click.option("--ubuntu-version", default="xenial")
@click.option(
    "--priority-threshold",
    default="medium",
    type=click.Choice(PRIORITY_PATTERNS.keys()),
)
@click.option("--any-status", is_flag=True)
def scan(
    packages_listing,
    active_cve_directory,
    ubuntu_version,
    priority_threshold,
    any_status,
):
    """Scan your packages listing for CVE numbers"""
    cves = load_cves(active_cve_directory, ubuntu_version, priority_threshold)
    next(packages_listing)  # remove header
    for package_line in packages_listing:
        package, _, _ = package_line.partition(b"/")
        package = package.decode("utf-8")
        if package in cves:
            output_details(package, cves[package], any_status)

    order_critical = sorted(critical, key=itemgetter("cvss"), reverse=True)
    order_high = sorted(high, key=itemgetter("cvss"), reverse=True)
    order_medium = sorted(medium, key=itemgetter("cvss"), reverse=True)
    order_low = sorted(low, key=itemgetter("cvss"), reverse=True)

    severity_files_output(order_critical, "critical")
    severity_files_output(order_high, "high")
    severity_files_output(order_medium, "medium")
    severity_files_output(order_low, "low")


def severity_files_output(severity_list, severity):
    cve_file = open(f"{severity}.txt", "w")
    url_file = open(f"{severity}_useful_links.txt", "w")
    for vuln in severity_list:
        cve_file.write(
            SEVERITY_FILE_TEMPLATE.format(
                package=vuln["package"],
                cve=vuln["cve"],
                cvss=vuln["cvss"],
                comments=vuln["comments"],
            )
        )
        year = vuln["cve"][4:8]
        url_file.write(
            USEFUL_INFO_TEMPLATE.format(
                cve=vuln["cve"],
                year=year,
            )
        )
    cve_file.close()

    


def output_details(package, cves, any_status=False):
    for cve, status in cves:
        package_lists["package"] = package
        package_lists[package]["cve"] = cve

        if any_status:
            print_cve(cve, package)
        elif "need" in status:
            print_cve(cve, package)


def print_cve(cve, package):
    details = json.loads(CVE.id(cve).decode("utf-8"))
    if details:
        severity = {"severity": get_cvss_severity(details)}
        details.update(severity)
        package_lists[package][cve]["package"] = package
        package_lists[package][cve]["cve"] = cve
        package_lists[package][cve]["cvss"] = details["cvss"]
        package_lists[package][cve]["severity"] = details["severity"]
        package_lists[package][cve]["comments"] = details["summary"]
        cve_dict = Dict()
        cve_dict.cve = cve
        cve_dict.cvss = details["cvss"]
        cve_dict.package = package
        cve_dict.comments = details["summary"]

        order_cves(details, cve, package)

        print(
            CVE_DETAILS_TEMPLATE.format(
                id=cve,
                package=package,
                cvss=details["cvss"],
                severity=details["severity"],
                published=details["Published"],
                modified=details["Modified"],
                summary=details["summary"],
                references=" ".join(details["references"]),
            )
        )
    else:
        print(CVE_NO_DETAILS_TEMPLATE.format(id=cve, package=package))


def order_cves(details, cve, package):
    if details["severity"] == "Critical Risk":
        critical.append(package_lists[package][cve])
    if details["severity"] == "High Risk":
        high.append(package_lists[package][cve])
    if details["severity"] == "Medium Risk":
        medium.append(package_lists[package][cve])
    if details["severity"] == "Low Risk":
        low.append(package_lists[package][cve])


def load_cves(active_cve_directory, ubuntu_version, threshold):
    cves = defaultdict(list)
    package_regex = re.compile(
        "{}_(?P<package_name>[\w_-]*): (?P<status>\w*)".format(ubuntu_version)
    )
    for filename in filter(
        lambda fn: fn.startswith("CVE"), os.listdir(active_cve_directory)
    ):
        with open(os.path.join(active_cve_directory, filename)) as f:
            contents = f.read()
            matches = []
            if re.search(PRIORITY_PATTERNS[threshold], contents) != None:
                matches = re.finditer(package_regex, contents)
            for match in matches:
                match_dict = match.groupdict()
                cves[match_dict["package_name"]].append(
                    (filename, match_dict["status"])
                )
    return cves


def get_cvss_severity(details):
    cvss = details["cvss"]
    if cvss > 9.0:
        severity = "Critical Risk"
    elif cvss > 6.9:
        severity = "High Risk"
    elif cvss > 3.9:
        severity = "Medium Risk"
    else:
        severity = "Low Risk"
    return severity


@click.group()
def ssh_packages():
    pass


@ssh_packages.command()
@click.option("--user")
@click.option(
    "--server",
    help="The IP or domain name of the server you want to connect to, this can be the internal IP if you're using a jumpbox. Should be left when hosts is used.",
    default=None
)
@click.option(
    "--jumpbox_public_addr",
    default=None,
    help="The public IP or domain name of your jumpbox.",
)
@click.option(
    "--jumpbox_private_addr",
    default=None,
    help="The private IP of your jumpbox."
)
@click.option(
    "--ssh_key",
    help="Full path to your SSH key.",
    default=f"{os.getenv('HOME')}/.ssh/id_rsa",
)
@click.option(
    "--hosts",
    default=None,
    help="The file containing a list of hosts to get package lists from.",
    type=click.File("rb")
)
@click.option("--passphrase", help="Prompt for passphrase for your SSH key.", flag_value=True)
def apt_list_installed(
    user,
    server,
    ssh_key,
    jumpbox_public_addr,
    jumpbox_private_addr,
    passphrase,
    hosts,
):
    """SSH into server for package listing"""
    key_passphrase = None
    if passphrase:
        try:
            key_passphrase = getpass.getpass()
        except Exception as e:
            print(f"Unable to get SSH passphrase: {e}")


    if hosts:
        for host in hosts:
            server = host
            get_packages(
                user,
                server,
                ssh_key,
                jumpbox_public_addr,
                jumpbox_private_addr,
                key_passphrase,
            )
    elif server:
        get_packages(
            user,
            server,
            ssh_key,
            jumpbox_public_addr,
            jumpbox_private_addr,
            key_passphrase,
        )
    else:
        print("Please specify either a single server or a hosts file with the --server or --hosts option.")


def get_packages(
    user, server, ssh_key, jumpbox_public_addr, jumpbox_private_addr, key_passphrase
):
    if jumpbox_public_addr and jumpbox_private_addr:
        jumpbox = paramiko.SSHClient()
        jumpbox.load_system_host_keys()
        jumpbox.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        if key_passphrase:
            jumpbox.connect(
                hostname=jumpbox_public_addr,
                username=user,
                password=key_passphrase,
                key_filename=ssh_key,
            )
        else:
            try:
                jumpbox.connect(
                    hostname=jumpbox_public_addr,
                    username=user,
                    key_filename=ssh_key,
                )
            except paramiko.ssh_exception.PasswordRequiredException:
                print("The private SSH key requires a password, use --passphrase to enter.")
                sys.exit(1)
        jumpbox_transport = jumpbox.get_transport()
        jumpbox_channel = jumpbox_transport.open_channel(
            "direct-tcpip", (jumpbox_private_addr, 22), (server, 22)
        )
    else:
        jumpbox_channel = None

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    if key_passphrase:
        client.connect(
            hostname=server,
            username=user,
            password=key_passphrase,
            key_filename=ssh_key,
            sock=jumpbox_channel,
            )
    else:
        try:
            client.connect(
                hostname=server,
                username=user,
                key_filename=ssh_key,
                sock=jumpbox_channel,
            )
        except paramiko.ssh_exception.PasswordRequiredException:
                print("The private SSH key requires a password, use --passphrase to enter.")
                sys.exit(1)

    stdin, stdout, stderr = client.exec_command("apt list --installed")
    output = stdout.readlines()
    no_newlines = server.replace(b"\n", b"")
    file_name = no_newlines.decode("utf-8").replace(".", "_")
    
    file = open(f"installed_packages_{file_name}.txt", "w")
    file.write("".join(output))
    file.close()
    client.close()
    jumpbox.close()


cli = click.CommandCollection(sources=[scan_packages, ssh_packages])


if __name__ == "__main__":
    cli()
