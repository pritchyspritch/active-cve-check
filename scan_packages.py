import os
import re
import csv
from collections import defaultdict
import json


import click
import paramiko
from ares import CVESearch
from addict import Dict


PRIORITY_PATTERNS = {
    "low": re.compile("Priority:"),
    "medium": re.compile("Priority: [mh]"),
    "high": re.compile("Priority: [h]"),
}
CVE = CVESearch()


CVE_DETAILS_TEMPLATE = """
CVE: {id}
Package: {package}
CVSS: {cvss}
CVSS 2.0 Severity: {severity}
Published: {published}
Modified: {modified}
Summary: {summary}
References: {references}
"""


CVE_NO_DETAILS_TEMPLATE = """
CVE: {id}
Package: {package}
No further details available.
"""


ORDERED_CVES_TEMPLATE = """
Package: {package}
CVE: {cve}
CVSS: {cvss}
Comments: {comments}

------
"""

high = []
medium = []
low = []
cve_output = []
# package_lists = defaultdict(list)
package_lists = defaultdict(lambda: defaultdict(dict))


@click.group()
def scan_packages():
    pass


@scan_packages.command()
@click.argument("packages_listing", type=click.File("rb"))
@click.argument(
    "active_cve_directory", type=click.Path(exists=True, dir_okay=True, file_okay=False)
)
@click.option("--ubuntu-version", default="xenial")
@click.option(
    "--priority-threshold",
    default="medium",
    type=click.Choice(PRIORITY_PATTERNS.keys()),
)
@click.option("--any-status", is_flag=True)
def scan(
    packages_listing,
    active_cve_directory,
    ubuntu_version,
    priority_threshold,
    any_status,
):
    """Scan your packages listing for CVE numbers"""
    cves = load_cves(active_cve_directory, ubuntu_version, priority_threshold)
    next(packages_listing)  # remove header
    for package_line in packages_listing:
        package, _, _ = package_line.partition(b"/")
        package = package.decode("utf-8")
        if package in cves:
            # group_dicts(package)
            output_details(package, cves[package], any_status)
    # dict_to_file()
    print(json.dumps(package_lists, indent=4))
    print(f"High: {high}\n\n Medium: {medium}\n\n Low: {low}")


def dict_to_file():
    # print(f"High: {high}, Medium: {medium}, Low: {low}")
    cve_file = open("ordered_cves.txt", "w")
    cve_file.write("High Risk:\n")
    for vulns in high:
        cve_file.write(
            ORDERED_CVES_TEMPLATE.format(
                cve=vulns.cve,
                cvss=vulns.cvss,
                package=vulns.package,
                comments=vulns.comments,
            )
        )
    cve_file.write("\n\nMedium Risk:\n")
    for vulns in medium:
        cve_file.write(
            ORDERED_CVES_TEMPLATE.format(
                cve=vulns.cve,
                cvss=vulns.cvss,
                package=vulns.package,
                comments=vulns.comments,
            )
        )
    cve_file.write("\n\nLow Risk:\n")
    for vulns in low:
        cve_file.write(
            ORDERED_CVES_TEMPLATE.format(
                cve=vulns.cve,
                cvss=vulns.cvss,
                package=vulns.package,
                comments=vulns.comments,
            )
        )
    cve_file.close()


def output_details(package, cves, any_status=False):
    for cve, status in cves:
        package_lists["package"] = package
        package_lists[package]["cve"] = cve

        if any_status:
            print_cve(cve, package)
        elif "need" in status:
            print_cve(cve, package)


def print_cve(cve, package):
    details = json.loads(CVE.id(cve).decode("utf-8"))
    if details:
        severity = {"severity": get_cvss_severity(details)}
        details.update(severity)
        package_lists[package][cve]["package"] = package
        package_lists[package][cve]["cve"] = cve
        package_lists[package][cve]["cvss"] = details["cvss"]
        package_lists[package][cve]["severity"] = details["severity"]
        package_lists[package][cve]["comments"] = details["summary"]
        cve_dict = Dict()
        cve_dict.cve = cve
        cve_dict.cvss = details["cvss"]
        cve_dict.package = package
        cve_dict.comments = details["summary"]
        # package.cves.append(cve)
        # package.cvss.append(details["cvss"])
        # package.comments.append(details["summary"])

        # order_cves(details, cve_dict)
        order_cves(details, cve, package)

        print(
            CVE_DETAILS_TEMPLATE.format(
                id=cve,
                package=package,
                cvss=details["cvss"],
                severity=details["severity"],
                published=details["Published"],
                modified=details["Modified"],
                summary=details["summary"],
                references=" ".join(details["references"]),
            )
        )
    else:
        print(CVE_NO_DETAILS_TEMPLATE.format(id=cve, package=package))


# def group_dicts(package):
#     package = Dict()
#     package.cves = []
#     package.cvss = []
#     package.comments = []


# def order_cves(details, cve_dict):
def order_cves(details, cve, package):
    if details["severity"] == "High Risk":
        high.append(package_lists[package][cve])
    if details["severity"] == "Medium Risk":
        medium.append(package_lists[package][cve])
    if details["severity"] == "Low Risk":
        low.append(package_lists[package][cve])


def load_cves(active_cve_directory, ubuntu_version, threshold):
    cves = defaultdict(list)
    package_regex = re.compile(
        "{}_(?P<package_name>[\w_-]*): (?P<status>\w*)".format(ubuntu_version)
    )
    for filename in filter(
        lambda fn: fn.startswith("CVE"), os.listdir(active_cve_directory)
    ):
        with open(os.path.join(active_cve_directory, filename)) as f:
            contents = f.read()
            matches = []
            if re.search(PRIORITY_PATTERNS[threshold], contents) != None:
                matches = re.finditer(package_regex, contents)
            for match in matches:
                match_dict = match.groupdict()
                cves[match_dict["package_name"]].append(
                    (filename, match_dict["status"])
                )
    return cves


def get_cvss_severity(details):
    cvss = details["cvss"]
    if cvss > 6.9:
        severity = "High Risk"
    elif cvss > 3.9:
        severity = "Medium Risk"
    else:
        severity = "Low Risk"
    return severity


@click.group()
def ssh_packages():
    pass


@ssh_packages.command()
@click.option("--user")
@click.option(
    "--server",
    help="The IP or domain name of the server you want to connect to, this can be the internal IP if you're using a jumpbox. Should be left when hosts is used.",
    default=None
)
@click.option(
    "--jumpbox_public_addr",
    default=None,
    help="The public IP or domain name of your jumpbox.",
)
@click.option(
    "--jumpbox_private_addr",
    default=None,
    help="The private IP of your jumpbox."
)
@click.option(
    "--ssh_key",
    help="Full path to your SSH key.",
    default=f"{os.getenv('HOME')}/.ssh/id_rsa",
)
@click.option(
    "--hosts",
    default=None,
    help="The file containing a list of hosts to get package lists from.",
    type=click.File("rb")
)
@click.option("--key_passphrase", help="Passphrase for your SSH key.", default=None)
def apt_list_installed(
    user,
    server,
    ssh_key,
    jumpbox_public_addr,
    jumpbox_private_addr,
    key_passphrase,
    hosts,
):
    """SSH into server for package listing"""
    if hosts:
        for host in hosts:
            server = host
            get_packages(
                user,
                server,
                ssh_key,
                jumpbox_public_addr,
                jumpbox_private_addr,
                key_passphrase,
            )
    elif server:
        get_packages(
            user,
            server,
            ssh_key,
            jumpbox_public_addr,
            jumpbox_private_addr,
            key_passphrase,
        )
    else:
        print("Please specify either a single server or a hosts file with the --server or --hosts option.")


def get_packages(
    user, server, ssh_key, jumpbox_public_addr, jumpbox_private_addr, key_passphrase
):
    if jumpbox_public_addr and jumpbox_private_addr:
        jumpbox = paramiko.SSHClient()
        jumpbox.load_system_host_keys()
        jumpbox.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        jumpbox.connect(
            hostname=jumpbox_public_addr,
            username=user,
            password=key_passphrase,
            key_filename=ssh_key,
        )

        jumpbox_transport = jumpbox.get_transport()
        jumpbox_channel = jumpbox_transport.open_channel(
            "direct-tcpip", (jumpbox_private_addr, 22), (server, 22)
        )
    else:
        jumpbox_channel = None

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    client.connect(
        hostname=server,
        username=user,
        password=key_passphrase,
        key_filename=ssh_key,
        sock=jumpbox_channel,
    )
    stdin, stdout, stderr = client.exec_command("apt list --installed")
    output = stdout.readlines()
    no_newlines = server.replace(b"\n", b"")
    file_name = no_newlines.decode("utf-8").replace(".", "_")
    
    file = open(f"installed_packages_{file_name}.txt", "w")
    file.write("".join(output))
    file.close()
    client.close()
    jumpbox.close()


cli = click.CommandCollection(sources=[scan_packages, ssh_packages])


if __name__ == "__main__":
    cli()
